

1- Modular Feature Architecture (Feature Modules).
Cada feature contiene sus piezas internas, mientras que app/ contiene √∫nicamente el routing.
Es un patr√≥n de organizaci√≥n donde cada feature del negocio tiene un m√≥dulo autocontenido que incluye UI, l√≥gica, tipos y utilidades, mientras que las rutas viven aparte (en app/) y funcionan como puntos de entrada.

2 - Para editar una cuenta de usuario (OPERATOR, SUPERVISOR, ADMIN) debe hacerse desde el panel de Clerk
3- Webhook de Clerk que apunta a: https://263fdb80536a.ngrok-free.app/api/users/sync. eventos a los que suscribe: 
session.created
session.ended
session.revoked
user.created
user.deleted
user.updated
Esto crea/edita/elimina la/las cuentas en la base de datos para utilizar en las auditorias. Se sincroniza la info de las cuentas de clerk y mi base de datos.
4- La creaci√≥n de cuentas est√° deshabilitada desde clerk. solo el desarrollador puede crear cuentas.


5- Comandos para ejecutar los archivos seeds y cargar la base de datos de data de prueba: 
    ----crear provincias y ciudades: npx tsx prisma/scripts/create-provinces-and-cities.ts
    ----crear 10 afiliados: npx tsx prisma/scripts/create-affiliates.ts
    ----crear 7 servicios: npx tsx prisma/scripts/create-services.ts
    ----crear organizaciones: npx tsx prisma/scripts/create-organizations.ts
    ----crear productos para farmacia-medicamentos: npx tsx prisma/scripts/create-pharmacy-medications.ts
    ----crear productos para farmacia-general: npx tsx prisma/scripts/create-pharmacy-general.ts

    

6- en app > api > services > find-all - route.ts se cachea la response con un tiempo de 1 semana ya que rara vez van a cambiar.
    
7- establec√≠ en la configuracion de clerk en el apartado Sessions que el Maximun lifetime sea de 1 dia en vez de 7, si bien se puede hacer, pero en el plan free esto solo funciona en development, para produccion hay que pagar.

8- en el layout.tsx principal configur√© en el ClerkProvider que se redireccione a "/" cuando se cierra sesi√≥n.

9- para crear los distintos tipos de vistas segun el rol de la cuenta autenticada se utiliza un endpoint en la carpeta api, ya que clerk no administra el tipo de cuenta/rol, solo maneja el login. para realizar las verificaciones de que tipo de cuenta est√° activa utilizo mi base de datos, por eso creo un endpoint para esto.

10- Los archivos de componentes deben comenzar con may√∫scula (PascalCase). Usar named exports en lugar de default exports.

11- Cuando reseteo la base para aplciar nuevos cambios en el schema.prisma, debo volver a crear el/los usuarios manualmente desde la pagina de clerk y actualizar el link del endpoint del webhook en clerk y loguearme con la/las cuentas creadas desde el link de ngrok para que esa/esas cuentas se creen en la base de datos. luego de hacer esto ya se puede acceder con el link: localhost:3000 y como el/los usuarios ya existen en la base ya permite loguearse correctamente.

12- Los nombres de los archivos en features > m√≥dulo > services utiliza una convenci√≥n de servicios basada en acciones(backend-driven frontends).Este patr√≥n basado en verbos (get/create/update/delete) expresa claramente la intenci√≥n del servicio y es exactamente lo que esperar√≠a cualquier desarrollador en un entorno productivo.

13- Un Client Component NO puede acceder directamente a la base de datos, por lo que necesita un endpoint o un server action.
    Un Server Component y Server Actions pueden acceder a la base de datos (ejemplo: db.user.findMany)

14- se implementa RBAC en el archivo proxy.ts para proteger las rutas autenticadas. (por ejemplo: que una cuenta con el rol OPERATOR no pueda modificar la url y acceder a un path que es exclusivo de cuentas con el rol ADMIN). Ademas, en los endpoints hay proteccion adicional a las acciones dependiendo el rol (por ejemplo: si una cuenta con rol OPERATOR pudiera acceder a un path que no debe, no va a poder ejecutar ninguna accion de agregar/editar/eliminar/ver porque los endpoints verifican el rol de la cuenta que solicita la accion.)

15- Seguridad de la pagina ---- existen tres niveles de control, cada uno con un objetivo distinto:
        capa 1 -  archivo:  proxy.ts (middleware) objetivo: Control de acceso a rutas (autorizaci√≥n coarse-grained)
        capa 2 - archivo: app > (private) - layout.tsx objetivo: Garantizar sesi√≥n + usuario DB consistente.
        capa 3 - archivo: app > api (en los endpoints que ejecuten acciones que lo requieran, se utiliza la funcion requireRole) objetivo: Autorizaci√≥n funcional / de negocio (fine-grained)

    grafico arquitectura de seguridad: 
    
     proxy.ts     ‚îÇ  ‚Üê protege rutas por prefijo (macro)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ PrivateLayout‚îÇ  ‚Üê sesi√≥n + usuario DB
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Page         ‚îÇ  ‚Üê permisos funcionales / UX
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ API / Action ‚îÇ  ‚Üê requireRole (seguridad dura)

16- los endpoints de provinces y cities tienen una cache revalidate de 24hs.



estoy creando una pagina web de uso interno para una obra social con nextjs (version 16) prisma, postgres, typescrypt, shadcn, zod, tailwind. utilizo Modular Feature Architecture (Feature Modules).
Cada feature contiene sus piezas internas, mientras que app/ contiene √∫nicamente el routing.
Es un patr√≥n de organizaci√≥n donde cada feature del negocio tiene un m√≥dulo autocontenido que incluye UI, l√≥gica, tipos y utilidades, mientras que las rutas viven aparte (en app/) y funcionan como puntos de entrada.





Mejoras a realizar: 

1- Migrar b√∫squedas y edici√≥n de afiliados a TanStack Query
  - Centralizar cache de afiliados
  - Evitar prop drilling (onUpdated)
  - Manejar sincronizaci√≥n post-mutation autom√°ticamente
  - Posibilitar invalidaci√≥n / refetch selectivo

usar la funcion updateUserActivity en las acciones que tengan que refrescar el estado online/offline

agregar a la funcion formatLastActivity.ts que distinga dias. 


en la seccion del carrito, todos los productos dicen "Medicamento seleccionado" debajo del nombre, hay que crear una propiedad nueva en el model para guardar si son comprimidos, tabletas, gotas ,etc

La l√≥gica de negocio espec√≠fica de cada servicio debe estar desacoplada de los elementos transversales de la UI, deleg√°ndose mediante adapters para evitar dependencias cruzadas y permitir que cada servicio evolucione de forma independiente.

formatear metadata del modal de auditorias segun action









este proyecto tuvo dos objetivos principales: 1- desarrollar un sistema mas grande y complejo de los que venia haciendo, 2- utilizar alguna tecnologia de realtime ya que no habia utilizado ninguna.
otro de los objetivos fu√© tener que implementar arquitectura de software mas compleja, ya que al ser un proyecto m√°s grande, la cantidad de archivos, carpetas, routas etc es mucho mayor. hubo decisiones de arquitectura que pude identificar desde un principio y otras que tuve que enfrentarme al problema para luego refatorizar e implementar dicha solucion. este proceso fu√© lo m√°s enriquecedor de este proyecto, ya que al haber sucedido de esta manera me acuerdo de los procesos que tuve que pasar hasta llegar a una solucion acorde al problema(lo hice como yo pensaba que era lo mejor, me di cuenta de los problemas que esto generaba, recalcul√©, pens√©, investigu√©, evalu√© y refactoric√© implementando la solucion que consider√© mas adecuada). la aplicacion est√° desarrollada con nextjs, tailwind, sahdcn, prisma, postgressql. la base de datos se ejecuta en un contenedor docker. utilizo clerk para la autenticacion. a las cuentas de los usuarios del sistema las creo y√≥ desde el panel de clerk, no permito que un usuario (por mas que sea admin) pueda crear nuevas cuentas, esto lo decid√≠ para evitar problemas a futuro. las cuentas pueden tener 3 tipos de roles: ADMIN, SUPERVISOR, OPERATOR. los roles ADMIN y SUPERVISOR comparten la misma interfaz grafica, la diferencia radica en las acciones que pueden ejecutar. el rol ADMIN tiene permisos para hacer todo lo que permite la aplicacion, el rol SUPERVISOR puede ver lo mismo que el ADMIN pero no puede modificar nada. el rol OPERATOR es para los trabajadores de la obra social. el usuario ADMIN puede asociar el/los servicios que se requieran a una determinada cuenta OPERATOR (esto permite que un usuario OPERATOR tenga la opcion de entrar a, por ejemplo, el area de afiliaciones y al area de farmacia-general). el sistema utiliza dos webhooks de clerk: uno para las sesiones de usuario y otro para la sincronizacion de las cuentas entre clerk y la base de datos. las cuentas son creadas desde el panel de clerk, y al iniciar sesion por primera vez en el sistema con dicha cuenta, esta cuenta es creada en la base de datos. el segundo inicio de sesion con esta cuenta, al ya existir en la base de datos no se vuelve a crear. cualquier cambio en la informacion de las cuentas (nombre, apellido, email, imagen de perfil) que se modifique en clerk se sincroniza automaticamente en la base de datos. la pagina principal (localhost:3000) muestra 3 opciones. la primera opcion es "iniciar sesion", a la cual se accede a distintos dashboards dependiendo el rol de la cuenta con la que se acceda. si se accede como ADMIN se muestra el dashboard para admins a donde se permite ver toda la informacion correspondiente como asi tambien modificar informacion (activar/desactivar servicios activos, editar un usuario, etc). si se accede con una cuenta cuyo rol es Supervisor, se muestra la misma interfaz grafica que para el ADMIN con la diferencia que no se permiten ediciones de informacion (solo lectura). si se accede con una cuenta OPERATOR, se muestra una pagina que lista el/los servicios que dicha cuenta tiene asociados, esto permite que una cuenta OPERATOR pueda trabajar en 1 o m√°s areas con la misma cuenta. todas las areas comparten un layout que consta de un header que muestra el nombre del area a la que se accedi√≥, el nombre, apellido y rol de la cuenta autenticada y un boton para cerrar sesion y lo mas importante: el panel de turnos. el panel de turnos funciona en realtime utilizando "pusher". cuando un afiliado genera un turno a una determianda √°rea, el usuario OPERATOR que est√° autenticado en dicha area v√© de manera inmediata que el boton "llamar siguiente turno" se activa, al presionar dicho boton el turno es llamado, mostrando en el panel de turnos el c√≥digo del ticket (por ejemplo: FM-1), esto sirve para que el afiliado se presente en el box para ser atendido debe presentar el ticket y el usuario OPERATOR constatar que el ticket es el correcto. ademas, cuando el usuario OPERATOR llama a un turno, este llamado impacta directamente en otra pagina llamada "Visor de turnos" que es la p√°gina que se muestra en diversas pantallas repartidas en la/las salas de espera, a donde los afiliados pueden ver un historial de los ultimos 5 turnos llamados y el que est√° siendo llamado (esta pagina muestra el nombre, apellido y el codigo del ticket). esta pagina tambien funciona en realtime con pusher. cuando el usuario OPERATOR llama a un turno debe esperar a que el afiliado se presente en el box correspondiente, y luego de constatar que el ticket que presenta el afiliado es correcto, debe presionar el boton "Iniciar atencion" que se encuentra en el panel de turnos. esto lo dise√±√© asi porque el sistema registra todas las unidades de tiempo, por ejemplo: segundos transcurridos desde que el afiliado gener√≥ un turno hasta que fu√© llamado, segundos transcurridos desde que se inici√≥ la atencion hasta que se finializ√≥ el turno. de esta manera, el tiempo que el afiliado pudiera tardar desde que es llamado hasta que se presenta en el box correspondiente, no se lo cuente como tiempo de atencion al usuario OPERATOR, ya que al mostrar graficos estadisticos sobre la duracion de la atencion de los turnos, turnos atendidos por x usuario, promedio de turnos atendidos por area etc, si contara el tiempo que el afiliado tarda en presentarse seria una desicronizacion que penalizaria a los usuarios OPERATOR. otra funcionalidad que comparten todas las areas y que forma parte del layout es un peque√±o panel debajo del panel de turnos que inicia cuando se inicia la atencion del turno, que muestra el tiempo transcurrido desde que se inici√≥ la atencion. se muestra una barra de carga que empieza en verde, y dependiendo del tiempo transcurrido cambia a amarillo y finalmente a rojo. la barra de carga tiene un tiempo maximo preestablecido de 12 minutos que es la convencion del tiempo m√°ximo que un usuario OPERATOR deberia tardar como maximo en atender un turno. esto no tiene una penalizacion directa al usuario OPERATOR que exeda este tiempo (el peido del afiliado puede ser muy grande y es normal que se tarde m√°s), es solo una interfaz gr√°fica para que el usuario OPERATOR pueda ver el tiempo transcurrido y si est√° dentro de los limites ideales. esto si puede repercutir en los graficos estadisticos que pueden ver el/los usuarios ADMIN y SUPERVISOR desde los cuales se puede observar que usuario est√° tardando mas de lo estipulado en despachar un turno, de que area es, etc. lueg de llamar a un turno, en le panel de turnos se muestran las opciones: iniciar atencion (al clikearlo el turno se llama, se muestra la barra de tiempo, se muestra el turno llamado en la/las pantalla de visor de turnos), en el caso de que el usuario OPERATOR llame a un turno y el afiliado llamado no se presente, el panel de tunos tiene un boton "Ausente", en el caso de que el afiliado se presente y no se concreta una orden (el afiliado se arrepiente, se retira del establecimiento, no hay el/los productos que solicita, es decir que el turno se inicia correctamente pero no se carga ningun producto a la orden, el sistema no permite finalizar un turno con una orden vaci√°, por lo que el usuario OPERATOR debe presionar en "cancelar" en el panel de turnos). el sistema utiliza un archivo proxy que funciona como Middleware de Seguridad y Enrutamiento Din√°mico (RBAC)
Este archivo act√∫a como el "Guardi√°n" (Gatekeeper) de la aplicaci√≥n. Es un Middleware de Next.js que centraliza la autenticaci√≥n con Clerk, la autorizaci√≥n basada en roles (RBAC) con Prisma y la auditor√≠a de seguridad.

üöÄ Funcionalidades Clave
Redirecci√≥n Inteligente (Smart Dashboard):
En lugar de tener m√∫ltiples URLs de inicio, implement√© un punto de entrada √∫nico (/dashboard). El middleware consulta el rol del usuario en la base de datos y lo redirige autom√°ticamente a su panel correspondiente (/admin, /supervisor u /operator), mejorando la fluidez de la navegaci√≥n.

Sistema de Permisos por Jerarqu√≠a:
No utilizo simples comparaciones de strings. Implement√© una jerarqu√≠a de roles (ROLE_HIERARCHY). Esto permite que un Administrador tenga acceso intr√≠nseco a las rutas de Supervisor y Operador sin necesidad de duplicar permisos, siguiendo el principio de "menor privilegio".

Auditor√≠a de Seguridad Activa:
Si un usuario intenta acceder a una ruta para la cual no tiene nivel suficiente, el sistema no solo bloquea el acceso, sino que utiliza un auditService para registrar el incidente:

Qui√©n intent√≥ entrar.

Qu√© ruta solicit√≥.

Desde qu√© IP y dispositivo.

Qu√© rol era requerido.

Gesti√≥n de Rutas P√∫blicas:
Utilizo createRouteMatcher para definir una lista blanca de rutas (landing page, pantallas de turnos, APIs p√∫blicas) que deben ser accesibles sin autenticaci√≥n, garantizando que el rendimiento de la app no se vea afectado innecesariamente.
"Si un Operador intenta entrar manualmente a /admin/settings, el middleware detecta que su nivel de jerarqu√≠a es inferior al requerido, dispara una alerta silenciosa en el sistema de auditor√≠a para el equipo de seguridad y redirige al usuario al inicio de sesi√≥n."

con respecto a la arquitectura utilizada para la creacion de archivos y carpetas: 1- Modular Feature Architecture (Feature Modules).
Cada feature contiene sus piezas internas, mientras que app/ contiene √∫nicamente el routing.
Es un patr√≥n de organizaci√≥n donde cada feature del negocio tiene un m√≥dulo autocontenido que incluye UI, l√≥gica, tipos y utilidades, mientras que las rutas viven aparte (en app/) y funcionan como puntos de entrada.

todo lo que puede server component es server component, y lo que requiere de interacion es use client. si un client component necesita informacion de la base de datos, creo un endpoint en la carpeta app > api. los server components que necesitan interactuar con la base de datos no necesitan un endpoint, pueden acceder directamente, para esto utilizo las carpetas services que cada modulo define en su estructura interna.

otra arquitectura de software que utilic√© es la de adapters. dado que tengo 2 areas de la obra social que cuentan con venta de productos (farmacia general y farmacia medicamentos), opt√© por crearlas como areas separadas e independientes entre si, porque si bien actualmente los modelos de la base de datos de ambas areas actualmente son iguales, estas podrian evolucionar en un futuro y tom√© la decision de crearlas por separado. en una priemra instancia esto me parecia repetir codigo pero prefiero que sean independientes entre si, ya que, por ejemplo, si implementara la funcionalidad de que en farmacia medicamentos el afiliado tiene que presentar la receta firmada por un medico para x medicamento, esta funcionalidad no aplica a farmacia general, y si compartiera los mismos modelos, ambos quedarian acoplados. 