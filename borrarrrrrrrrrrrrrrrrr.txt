

1- Modular Feature Architecture (Feature Modules).
Cada feature contiene sus piezas internas, mientras que app/ contiene únicamente el routing.
Es un patrón de organización donde cada feature del negocio tiene un módulo autocontenido que incluye UI, lógica, tipos y utilidades, mientras que las rutas viven aparte (en app/) y funcionan como puntos de entrada.

2 - Para editar una cuenta de usuario (OPERATOR, SUPERVISOR, ADMIN) debe hacerse desde el panel de Clerk
3- Webhook de Clerk que apunta a: https://263fdb80536a.ngrok-free.app/api/users/sync. eventos a los que suscribe: 
session.created
session.ended
session.revoked
user.created
user.deleted
user.updated
Esto crea/edita/elimina la/las cuentas en la base de datos para utilizar en las auditorias. Se sincroniza la info de las cuentas de clerk y mi base de datos.
4- La creación de cuentas está deshabilitada desde clerk. solo el desarrollador puede crear cuentas.


5- Comandos para ejecutar los archivos seeds y cargar la base de datos de data de prueba: 
    ----crear 10 afiliados: npx tsx prisma/scripts/create-affiliates.ts
    ----crear 7 servicios: npx tsx prisma/scripts/create-services.ts

6- en app > api > services > find-all - route.ts se cachea la response con un tiempo de 1 semana ya que rara vez van a cambiar.
    
7- stablecí en la configuracion de clerk en el apartado Sessions que el Maximun lifetime sea de 1 dia en vez de 7, si bien se puede hacer, pero en el plan free esto solo funciona en development, para produccion hay que pagar.

8- en el layout.tsx principal configuré en el ClerkProvider que se redireccione a "/" cuando se cierra sesión.

9- para crear los distintos tipos de vistas segun el rol de la cuenta autenticada se utiliza un endpoint en la carpeta api, ya que clerk no administra el tipo de cuenta/rol, solo maneja el login. para realizar las verificaciones de que tipo de cuenta está activa utilizo mi base de datos, por eso creo un endpoint para esto.

10- Los archivos de componentes deben comenzar con mayúscula (PascalCase). Usar named exports en lugar de default exports.

11- Cuando reseteo la base para aplciar nuevos cambios en el schema.prisma, debo volver a crear el/los usuarios manualmente desde la pagina de clerk y actualizar el link del endpoint del webhook en clerk y loguearme con la/las cuentas creadas desde el link de ngrok para que esa/esas cuentas se creen en la base de datos. luego de hacer esto ya se puede acceder con el link: localhost:3000 y como el/los usuarios ya existen en la base ya permite loguearse correctamente.

12- Los nombres de los archivos en features > módulo > services utiliza una convención de servicios basada en acciones(backend-driven frontends).Este patrón basado en verbos (get/create/update/delete) expresa claramente la intención del servicio y es exactamente lo que esperaría cualquier desarrollador en un entorno productivo.

13- Un Client Component NO puede acceder directamente a la base de datos, por lo que necesita un endpoint o un server action.
    Un Server Component y Server Actions pueden acceder a la base de datos (ejemplo: db.user.findMany)



estoy creando una pagina web de uso interno para una obra social con nextjs (version 16) prisma, postgres, typescrypt, shadcn, zod, tailwind. utilizo Modular Feature Architecture (Feature Modules).
Cada feature contiene sus piezas internas, mientras que app/ contiene únicamente el routing.
Es un patrón de organización donde cada feature del negocio tiene un módulo autocontenido que incluye UI, lógica, tipos y utilidades, mientras que las rutas viven aparte (en app/) y funcionan como puntos de entrada.










