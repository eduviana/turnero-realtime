

1- Modular Feature Architecture (Feature Modules).
Cada feature contiene sus piezas internas, mientras que app/ contiene únicamente el routing.
Es un patrón de organización donde cada feature del negocio tiene un módulo autocontenido que incluye UI, lógica, tipos y utilidades, mientras que las rutas viven aparte (en app/) y funcionan como puntos de entrada.

2 - Para editar una cuenta de usuario (OPERATOR, SUPERVISOR, ADMIN) debe hacerse desde el panel de Clerk
3- Webhook de Clerk que apunta a: https://263fdb80536a.ngrok-free.app/api/users/sync. eventos a los que suscribe: 
session.created
session.ended
session.revoked
user.created
user.deleted
user.updated
Esto crea/edita/elimina la/las cuentas en la base de datos para utilizar en las auditorias. Se sincroniza la info de las cuentas de clerk y mi base de datos.
4- La creación de cuentas está deshabilitada desde clerk. solo el desarrollador puede crear cuentas.


5- Comandos para ejecutar los archivos seeds y cargar la base de datos de data de prueba: 
    ----crear provincias y ciudades: npx tsx prisma/scripts/create-provinces-and-cities.ts
    ----crear 10 afiliados: npx tsx prisma/scripts/create-affiliates.ts
    ----crear 7 servicios: npx tsx prisma/scripts/create-services.ts
    ----crear organizaciones: npx tsx prisma/scripts/create-organizations.ts
    ----crear productos para farmacia-medicamentos: npx tsx prisma/scripts/create-pharmacy-medications.ts
    ----crear productos para farmacia-general: npx tsx prisma/scripts/create-pharmacy-general.ts

    

6- en app > api > services > find-all - route.ts se cachea la response con un tiempo de 1 semana ya que rara vez van a cambiar.
    
7- stablecí en la configuracion de clerk en el apartado Sessions que el Maximun lifetime sea de 1 dia en vez de 7, si bien se puede hacer, pero en el plan free esto solo funciona en development, para produccion hay que pagar.

8- en el layout.tsx principal configuré en el ClerkProvider que se redireccione a "/" cuando se cierra sesión.

9- para crear los distintos tipos de vistas segun el rol de la cuenta autenticada se utiliza un endpoint en la carpeta api, ya que clerk no administra el tipo de cuenta/rol, solo maneja el login. para realizar las verificaciones de que tipo de cuenta está activa utilizo mi base de datos, por eso creo un endpoint para esto.

10- Los archivos de componentes deben comenzar con mayúscula (PascalCase). Usar named exports en lugar de default exports.

11- Cuando reseteo la base para aplciar nuevos cambios en el schema.prisma, debo volver a crear el/los usuarios manualmente desde la pagina de clerk y actualizar el link del endpoint del webhook en clerk y loguearme con la/las cuentas creadas desde el link de ngrok para que esa/esas cuentas se creen en la base de datos. luego de hacer esto ya se puede acceder con el link: localhost:3000 y como el/los usuarios ya existen en la base ya permite loguearse correctamente.

12- Los nombres de los archivos en features > módulo > services utiliza una convención de servicios basada en acciones(backend-driven frontends).Este patrón basado en verbos (get/create/update/delete) expresa claramente la intención del servicio y es exactamente lo que esperaría cualquier desarrollador en un entorno productivo.

13- Un Client Component NO puede acceder directamente a la base de datos, por lo que necesita un endpoint o un server action.
    Un Server Component y Server Actions pueden acceder a la base de datos (ejemplo: db.user.findMany)

14- se implementa RBAC en el archivo proxy.ts para proteger las rutas autenticadas. (por ejemplo: que una cuenta con el rol OPERATOR no pueda modificar la url y acceder a un path que es exclusivo de cuentas con el rol ADMIN). Ademas, en los endpoints hay proteccion adicional a las acciones dependiendo el rol (por ejemplo: si una cuenta con rol OPERATOR pudiera acceder a un path que no debe, no va a poder ejecutar ninguna accion de agregar/editar/eliminar/ver porque los endpoints verifican el rol de la cuenta que solicita la accion.)

15- Seguridad de la pagina ---- existen tres niveles de control, cada uno con un objetivo distinto:
        capa 1 -  archivo:  proxy.ts (middleware) objetivo: Control de acceso a rutas (autorización coarse-grained)
        capa 2 - archivo: app > (private) - layout.tsx objetivo: Garantizar sesión + usuario DB consistente.
        capa 3 - archivo: app > api (en los endpoints que ejecuten acciones que lo requieran, se utiliza la funcion requireRole) objetivo: Autorización funcional / de negocio (fine-grained)

    grafico arquitectura de seguridad: 
    
     proxy.ts     │  ← protege rutas por prefijo (macro)
└──────┬───────┘
       ↓
┌──────────────┐
│ PrivateLayout│  ← sesión + usuario DB
└──────┬───────┘
       ↓
┌──────────────┐
│ Page         │  ← permisos funcionales / UX
└──────┬───────┘
       ↓
┌──────────────┐
│ API / Action │  ← requireRole (seguridad dura)

16- los endpoints de provinces y cities tienen una cache revalidate de 24hs.



estoy creando una pagina web de uso interno para una obra social con nextjs (version 16) prisma, postgres, typescrypt, shadcn, zod, tailwind. utilizo Modular Feature Architecture (Feature Modules).
Cada feature contiene sus piezas internas, mientras que app/ contiene únicamente el routing.
Es un patrón de organización donde cada feature del negocio tiene un módulo autocontenido que incluye UI, lógica, tipos y utilidades, mientras que las rutas viven aparte (en app/) y funcionan como puntos de entrada.





Mejoras a realizar: 

1- Migrar búsquedas y edición de afiliados a TanStack Query
  - Centralizar cache de afiliados
  - Evitar prop drilling (onUpdated)
  - Manejar sincronización post-mutation automáticamente
  - Posibilitar invalidación / refetch selectivo

usar la funcion updateUserActivity en las acciones que tengan que refrescar el estado online/offline

agregar a la funcion formatLastActivity.ts que distinga dias. 

En TurnQueuePanel, la propiedad state que viene del hook useTurnQueue devuelve: 
{
    "currentTicket": null,
    "lastCalledTickets": [ //////////////creo que no lo estamos usando
        {
            "id": "cmkl92zw80000w89xcf35qvkg",
            "number": 52,
            "code": "FM-52",
            "status": "COMPLETED"
        }
    ],
    "pendingCount": 0
}


en la seccion del carrito, todos los productos dicen "Medicamento seleccionado" debajo del nombre, hay que crear una propiedad nueva en el model para guardar si son comprimidos, tabletas, gotas ,etc

La lógica de negocio específica de cada servicio debe estar desacoplada de los elementos transversales de la UI, delegándose mediante adapters para evitar dependencias cruzadas y permitir que cada servicio evolucione de forma independiente.